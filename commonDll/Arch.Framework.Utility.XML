<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Arch.Framework.Utility</name>
    </assembly>
    <members>
        <member name="T:Arch.Framework.Utility.Serialize.GoogleSerializer">
            <summary>
            Google序列化、反序列化工具类
            </summary>
        </member>
        <member name="T:Arch.Framework.Utility.Serialize.ISerializer">
            <summary>
            通用序列化、反序列化接口
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.ISerializer.Deserialize``1(System.String)">
            <summary>
            从字符串中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的格式化字符串</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.ISerializer.Deserialize``1(System.IO.Stream)">
            <summary>
            从当前流中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的流</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.ISerializer.Deserialize``1(System.Byte[])">
            <summary>
            从当前字节串中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的字节串</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.ISerializer.DeserializeFromFile``1(System.String)">
            <summary>
            从文件中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="fileName">T类型的格式化文件</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.ISerializer.Serialize``1(``0)">
            <summary>
            将T类序列化为一个字符串
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <returns>T类型的格式化字符串</returns>        
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.ISerializer.Serialize``1(``0,System.IO.Stream)">
            <summary>
            将T类序列化到一个流中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="destination">流</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.ISerializer.Serialize``1(``0,System.Byte[]@)">
            <summary>
            将T类序列化到一个字节序列中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="buf">字节序列</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.ISerializer.Serialize``1(``0,System.String)">
            <summary>
            将T类序列化到一个文件中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="fileName">输出的文件名</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.GoogleSerializer.Deserialize``1(System.String)">
            <summary>
            从字符串中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的格式化字符串</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.GoogleSerializer.Deserialize``1(System.IO.Stream)">
            <summary>
            从当前流中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的流</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.GoogleSerializer.Deserialize``1(System.Byte[])">
            <summary>
            从当前字节串中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的字节串</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.GoogleSerializer.DeserializeFromFile``1(System.String)">
            <summary>
            从文件中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="fileName">T类型的格式化文件</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.GoogleSerializer.Serialize``1(``0)">
            <summary>
            将T类序列化为一个字符串
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <returns>T类型的格式化字符串</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.GoogleSerializer.Serialize``1(``0,System.IO.Stream)">
            <summary>
            将T类序列化到一个流中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="destination">流</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.GoogleSerializer.Serialize``1(``0,System.Byte[]@)">
            <summary>
            将T类序列化到一个字节序列中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="buf">字节序列</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.GoogleSerializer.Serialize``1(``0,System.String)">
            <summary>
            将T类序列化到一个文件中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="fileName">输出的文件名</param>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.Write(System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Perform the steps necessary to serialize this data.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="dest">The writer entity that is accumulating the output data.</param>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.Read(System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Perform the steps necessary to deserialize this data.
            </summary>
            <param name="value">The current value, if appropriate.</param>
            <param name="source">The reader providing the input data.</param>
            <returns>The updated / replacement value.</returns>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.ExpectedType">
            <summary>
            The type that this serializer is intended to work for.
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue">
            <summary>
            Indicates whether a Read operation <em>replaces</em> the existing value, or
            <em>extends</em> the value. If false, the "value" parameter to Read is
            discarded, and should be passed in as null.
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.ReturnsValue">
            <summary>
            Now all Read operations return a value (although most do); if false no
            value should be expected.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel">
            <summary>
            Provides protobuf serialization support for a number of types that can be defined at runtime
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeModel">
            <summary>
            Provides protobuf serialization support for a number of types
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.TrySerializeAuxiliaryType(ProtoBuf.ProtoWriter,System.Type,ProtoBuf.DataFormat,System.Int32,System.Object,System.Boolean)">
            <summary>
            This is the more "complete" version of Serialize, which handles single instances of mapped types.
            The value is written as a complete field, including field-header and (for sub-objects) a
            length-prefix
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IEnumerable sequences of any type handled by TrySerializeAuxiliaryType
             
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object,ProtoBuf.SerializationContext)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver,System.Int32@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <param name="bytesRead">Returns the number of bytes consumed by this operation (includes length-prefix overheads and any skipped data).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
            <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver,ProtoBuf.SerializationContext)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
            <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
            <returns>The sequence of deserialized objects.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="type">The type being serialized.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="type">The type being serialized.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume (or -1 to read to the end of the stream).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.TryDeserializeAuxiliaryType(ProtoBuf.ProtoReader,ProtoBuf.DataFormat,System.Int32,System.Type,System.Object@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            This is the more "complete" version of Deserialize, which handles single instances of mapped types.
            The value is read as a complete field, including field-header and (for sub-objects) a
            length-prefix..kmc  
            
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IList sets of any type handled by TryDeserializeAuxiliaryType
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Create">
            <summary>
            Creates a new runtime model, to which the caller
            can add support for a range of types. A model
            can be used "as is", or can be compiled for
            optimal performance.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ResolveProxies(System.Type)">
            <summary>
            Applies common proxy scenarios, resolving the actual type to consider
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.IsDefined(System.Type)">
            <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetKey(System.Type@)">
            <summary>
            Provides the key that represents a given type in the current model.
            The type is also normalized for proxies at the same time.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetKeyImpl(System.Type)">
            <summary>
            Provides the key that represents a given type in the current model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.Int32,System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.Int32,System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeepClone(System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedSubtype(System.Type,System.Type)">
            <summary>
            Indicates that while an inheritance tree exists, the exact type encountered was not
            specified in that hierarchy and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedType(System.Type)">
            <summary>
            Indicates that the given type was not expected, and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowCannotCreateInstance(System.Type)">
            <summary>
            Indicates that the given type cannot be constructed; it may still be possible to 
            deserialize into existing instances.
            </summary>
        </member>
        <member name="E:ProtoBuf.Meta.TypeModel.DynamicTypeFormatting">
            <summary>
            Used to provide custom services for writing and parsing type names when using dynamic types. Both parsing and formatting
            are provided on a single API as it is essential that both are mapped identically at all times.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeModel.CallbackType">
            <summary>
            Indicates the type of callback to be used
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.BeforeSerialize">
            <summary>
            Invoked before an object is serialized
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.AfterSerialize">
            <summary>
            Invoked after an object is serialized
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.BeforeDeserialize">
            <summary>
            Invoked before an object is deserialized (or when a new instance is created)
            </summary>            
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.AfterDeserialize">
            <summary>
            Invoked after an object is deserialized
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetTypes">
            <summary>
            Returns a sequence of the Type instances that can be
            processed by this model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Add(System.Type,System.Boolean)">
            <summary>
            Adds support for an additional type in this model, optionally
            appplying inbuilt patterns. If the type is already known to the
            model, the existing type is returned **without** applying
            any additional behaviour.
            </summary>
            <remarks>Inbuilt patterns include:
            [ProtoContract]/[ProtoMember(n)]
            [DataContract]/[DataMember(Order=n)]
            [XmlType]/[XmlElement(Order=n)]
            [On{Des|S}erializ{ing|ed}]
            ShouldSerialize*/*Specified
            </remarks>
            <param name="type">The type to be supported</param>
            <param name="applyDefaultBehaviour">Whether to apply the inbuilt configuration patterns (via attributes etc), or
            just add the type with no additional configuration (the type must then be manually configured).</param>
            <returns>The MetaType representing this type, allowing
            further configuration.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.ThrowIfFrozen">
            <summary>
            Verifies that the model is still open to changes; if not, an exception is thrown
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Freeze">
            <summary>
            Prevents further changes to this model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetKeyImpl(System.Type)">
            <summary>
            Provides the key that represents a given type in the current model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Serialize(System.Int32,System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Deserialize(System.Int32,System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault">
            <summary>
            Global default for that
            enables/disables automatic tag generation based on the existing name / order
            of the defined members. See <seealso cref="P:ProtoBuf.ProtoContractAttribute.InferTagFromName"/>
            for usage and <b>important warning</b> / explanation.
            You must set the global default before attempting to serialize/deserialize any
            impacted type.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.UseImplicitZeroDefaults">
            <summary>
            Global switch that enables or disables the implicit
            handling of "zero defaults"; meanning: if no other default is specified,
            it assumes bools always default to false, integers to zero, etc.
            
            If this is disabled, no such assumptions are made and only *explicit*
            default values are processed. This is enabled by default to 
            preserve similar logic to v1.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Default">
            <summary>
            The default model, used to support ProtoBuf.Serializer
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Item(System.Type)">
            <summary>
            Obtains the MetaType associated with a given Type for the current model,
            allowing additional configuration.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoAddMissingTypes">
            <summary>
            Should support for unexpected types be added automatically?
            If false, an exception is thrown when unexpected types
            are encountered.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.MetadataTimeoutMilliseconds">
            <summary>
            The amount of time to wait if there are concurrent metadata access operations
            </summary>
        </member>
        <member name="T:ProtoBuf.IExtension">
            <summary>
            Provides addition capability for supporting unexpected fields during
            protocol-buffer serialization/deserialization. This allows for loss-less
            round-trip/merge, even when the data is not fully understood.
            </summary>
        </member>
        <member name="M:ProtoBuf.IExtension.BeginAppend">
            <summary>
            Requests a stream into which any unexpected fields can be persisted.
            </summary>
            <returns>A new stream suitable for storing data.</returns>
        </member>
        <member name="M:ProtoBuf.IExtension.EndAppend(System.IO.Stream,System.Boolean)">
            <summary>
            Indicates that all unexpected fields have now been stored. The
            implementing class is responsible for closing the stream. If
            "commit" is not true the data may be discarded.
            </summary>
            <param name="stream">The stream originally obtained by BeginAppend.</param>
            <param name="commit">True if the append operation completed successfully.</param>
        </member>
        <member name="M:ProtoBuf.IExtension.BeginQuery">
            <summary>
            Requests a stream of the unexpected fields previously stored.
            </summary>
            <returns>A prepared stream of the unexpected fields.</returns>
        </member>
        <member name="M:ProtoBuf.IExtension.EndQuery(System.IO.Stream)">
            <summary>
            Indicates that all unexpected fields have now been read. The
            implementing class is responsible for closing the stream.
            </summary>
            <param name="stream">The stream originally obtained by BeginQuery.</param>
        </member>
        <member name="M:ProtoBuf.IExtension.GetLength">
            <summary>
            Requests the length of the raw binary stream; this is used
            when serializing sub-entities to indicate the expected size.
            </summary>
            <returns>The length of the binary stream representing unexpected data.</returns>
        </member>
        <member name="T:Arch.Framework.Utility.Serialize.SoapSerializer">
            <summary>
            SOAP序列化、反序列化工具类
            </summary>
        </member>
        <member name="T:Arch.Framework.Utility.Serialize.BinSerializer">
            <summary>
            二进制序列化、反序列化工具类
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.Serialize.BinSerializer.serializers">
            <summary>
            序列化器缓存
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.BinSerializer.Deserialize``1(System.String)">
            <summary>
            从字符串中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的格式化字符串</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.BinSerializer.Deserialize``1(System.IO.Stream)">
            <summary>
            从当前流中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的流</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.BinSerializer.Deserialize``1(System.Byte[])">
            <summary>
            从当前字节串中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的字节串</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.BinSerializer.DeserializeFromFile``1(System.String)">
            <summary>
            从文件中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="fileName">T类型的格式化文件</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.BinSerializer.Serialize``1(``0)">
            <summary>
            将T类序列化为一个字符串
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <returns>T类型的格式化字符串</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.BinSerializer.Serialize``1(``0,System.IO.Stream)">
            <summary>
            将T类序列化到一个流中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="destination">流</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.BinSerializer.Serialize``1(``0,System.Byte[]@)">
            <summary>
            将T类序列化到一个字节序列中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="buf">字节序列</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.BinSerializer.Serialize``1(``0,System.String)">
            <summary>
            将T类序列化到一个文件中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="fileName">输出的文件名</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.BinSerializer.GetSerializer(System.Type)">
            <summary>
            从缓存中获取序列化对象,如果没有,则创建
            </summary>
            <returns>序列化对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.BinSerializer.GetFormatter">
            <summary>
            创建二进制序列化对象
            </summary>
            <returns>序列化对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.SoapSerializer.GetFormatter">
            <summary>
            创建SOAP序列化对象
            </summary>
            <returns>序列化对象</returns>
        </member>
        <member name="T:ProtoBuf.SubItemToken">
            <summary>
            Used to hold particulars relating to nested objects. This is opaque to the caller - simply
            give back the token you are given at the end of an object.
            </summary>
        </member>
        <member name="T:ProtoBuf.IExtensible">
            <summary>
            Indicates that the implementing type has support for protocol-buffer
            <see cref="T:ProtoBuf.IExtension">extensions</see>.
            </summary>
            <remarks>Can be implemented by deriving from <see cref="T:ProtoBuf.Extensible"/>.</remarks>
        </member>
        <member name="M:ProtoBuf.IExtensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="T:Arch.Framework.Utility.ChineseToSpell">
            <summary>
            汉字转换为拼音   
            <para>2011.11.30 修改筼[yun]厐[pang]万[wan]煦[xu]洋[yang]毜[hao],增加礽[reng]</para>
            <para>2011.12.21 替换整个字库为新的内容</para>
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.ChineseToSpell._Allhz">
            <summary>
            字库
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.ChineseToSpell.Convert(System.String)">
            <summary>
            汉字转拼音
            </summary>
            <param name="chinese">汉字字符</param>
            <returns>转换结果</returns>
        </member>
        <member name="T:Arch.Framework.Utility.Serialize.Base64Serializer">
            <summary>
            Base64序列化、反序列化对象
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.Base64Serializer.Deserialize``1(System.String)">
            <summary>
            从Base64编码字符串中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的格式化字符串</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.Base64Serializer.Serialize``1(``0)">
            <summary>
            将T类序列化为一个Base64编码字符串
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <returns>T类型的格式化字符串</returns>
        </member>
        <member name="T:ProtoBuf.ProtoEnumAttribute">
            <summary>
            Used to define protocol-buffer specific behavior for
            enumerated values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoEnumAttribute.HasValue">
            <summary>
            Indicates whether this instance has a customised value mapping
            </summary>
            <returns>true if a specific value is set</returns>
        </member>
        <member name="P:ProtoBuf.ProtoEnumAttribute.Value">
            <summary>
            Gets or sets the specific value to use for this enum during serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoEnumAttribute.Name">
            <summary>
            Gets or sets the defined name of the enum, as used in .proto
            (this name is not used during serialization).
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeFormatEventArgs">
            <summary>
            Event arguments needed to perform type-formatting functions; this could be resolving a Type to a string suitable for serialization, or could
            be requesting a Type from a string. If no changes are made, a default implementation will be used (from the assembly-qualified names).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.Type">
            <summary>
            The type involved in this map; if this is initially null, a Type is expected to be provided for the string in FormattedName.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.FormattedName">
            <summary>
            The formatted-name involved in this map; if this is initially null, a formatted-name is expected from the type in Type.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeFormatEventHandler">
            <summary>
            Delegate type used to perform type-formatting functions; the sender originates as the type-model.
            </summary>
        </member>
        <member name="T:ProtoBuf.ExtensibleUtil">
            <summary>
            This class acts as an internal wrapper allowing us to do a dynamic
            methodinfo invoke; an't put into Serializer as don't want on public
            API; can't put into Serializer&lt;T&gt; since we need to invoke
            accross classes, which isn't allowed in Silverlight)
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValuesTyped``2(``0,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            Reads the given value(s) from the instance's stream; the serializer
            is inferred from TValue and format. For singletons, each occurrence
            is merged [only applies for sub-objects], and the composed
            value if yielded once; otherwise ("repeated") each occurrence
            is yielded separately.
            </summary>
            <remarks>Needs to be public to be callable thru reflection in Silverlight</remarks>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.AppendExtendValueTyped``2(ProtoBuf.Meta.TypeModel,``0,System.Int32,ProtoBuf.DataFormat,``1)">
            <summary>
            Stores the given value into the instance's stream; the serializer
            is inferred from TValue and format.
            </summary>
            <remarks>Needs to be public to be callable thru reflection in Silverlight</remarks>
        </member>
        <member name="T:Arch.Framework.Utility.XMLProcessInfo">
            <summary>
            XML处理信息类
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.XMLProcessInfo.xmldoc">
            <summary>
            XML文档对象
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.XMLProcessInfo.xmlPath">
            <summary>
            XML路径
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.#ctor(System.String)">
            <summary>
            构造函数，该类需要处理的XML文档路径
            </summary>
            <param name="strPath">xml文件全路径</param>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.XMLLoad">
            <summary>
            导入XML文件
            </summary>
            <returns>XML文档对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.ReadNodeValue(System.String)">
            <summary>
            读取指定节点的数据
            </summary>
            <param name="node">符合XPath表达式的节点名</param>
            <returns>节点数据</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.ReadNodeAttribute(System.String,System.String)">
            <summary>
            得到指定节点的属性值
            </summary>
            <param name="node">符合XPath表达式的节点名</param>
            <param name="attribute">属性名</param>
            <returns>指定节点的属性值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.ReadAllChildallValue(System.String)">
            <summary>
            获取某一节点的所有孩子节点的值
            </summary>
            <param name="node">符合XPath表达式的节点名</param>
            <returns>该节点下的所有节点名字</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.ReadAllChildallInnerText(System.String)">
            <summary>
            获取某一节点的所有孩子节点的值
            </summary>
            <param name="node">符合XPath表达式的节点名</param>
            <returns>该节点下的所有节点的值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.ReadSingleNode(System.String)">
            <summary>
            根据给定的名字在XML文档中查询一个节点
            </summary>
            <param name="node">符合XPath表达式的节点名</param>
            <returns>查询到的节点</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.ReadAllChild(System.String)">
            <summary>
            获取某一节点的所有孩子节点的值
            </summary>
            <param name="node">符合XPath表达式的节点名</param>
            <returns>查询到的节点集合</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.Insert(System.String,System.String,System.String,System.String)">
            <summary>
            在指定节点上添加子节点
            </summary>
            <param name="parentNode">符合XPath表达式的节点名</param>
            <param name="element">插入节点的名字</param>
            <param name="attribute">插入节点的属性</param>
            <param name="value">插入节点的值</param>
            <returns>插入的节点</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.Insert(System.Xml.XmlElement,System.String,System.String)">
            <summary>
            在给定节点上添加子节点
            </summary>
            <param name="parentNode">要插入节点的节点</param>
            <param name="element">插入节点的名字</param>
            <param name="value">插入节点的值</param>
            <returns>插入的节点</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.Insert(System.String,System.Collections.ArrayList)">
            <summary>
            在指定节点名字的节点下插入节点集合
            </summary>
            <param name="parentNode">符合XPath表达式的节点名</param>
            <param name="elementValues">要加入的节点值得集合</param>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.Insert(System.Xml.XmlElement,System.Collections.ArrayList)">
            <summary>
            在指定节点下插入节点集合
            </summary>
            <param name="parentNode">要插入节点的节点</param>
            <param name="elementValues">要加入的节点值得集合</param>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.Update(System.String,System.String)">
            <summary>
            修改指定节点的数据
            </summary>
            <param name="node">符合XPath表达式的节点名</param>
            <param name="value">值</param>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.Update(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            更新指定节点下的指定子节点的值
            </summary>
            <param name="parentNode">父结点</param>
            <param name="node">符合XPath表达式的节点名</param>
            <param name="value">子节点值</param>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.RemoveNode(System.Xml.XmlNode)">
            <summary>
            删除指定节点
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.GetDataViewByXml(System.String,System.String)">
            <summary>
            读取Xml返回一个经排序或筛选后的DataView
            </summary>
            <param name="strWhere">筛选条件，如："name = 'kgdiwss'"</param>
            <param name="strSort">排序条件，如："Id desc"</param>
            <returns>经排序或筛选后的DataView对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcessInfo.Save">
            <summary>
            保存XML文档
            </summary>
        </member>
        <member name="P:Arch.Framework.Utility.XMLProcessInfo.XMLPath">
            <summary>
            Gets XML路径
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoIncludeAttribute">
            <summary>
            Indicates the known-types to support for an individual
            message. This serializes each level in the hierarchy as
            a nested message to retain wire-compatibility with
            other protocol-buffer implementations.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.Type)">
            <summary>
             Creates a new instance of the ProtoIncludeAttribute.
             </summary>
             <param name="tag">The unique index (within the type) that will identify this data.</param>
             <param name="knownType">The additional type to serialize/deserialize.</param>
        </member>
        <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new instance of the ProtoIncludeAttribute.
            </summary>
            <param name="tag">The unique index (within the type) that will identify this data.</param>
            <param name="knownTypeName">The additional type to serialize/deserialize.</param>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.Tag">
            <summary>
            Gets the unique index (within the type) that will identify this data.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownTypeName">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownType">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.DataFormat">
            <summary>
            Specifies whether the inherited sype's sub-message should be
            written with a length-prefix (default), or with group markers.
            </summary>
        </member>
        <member name="T:ProtoBuf.PrefixStyle">
            <summary>
            Specifies the type of prefix that should be applied to messages.
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.None">
            <summary>
            No length prefix is applied to the data; the data is terminated only be the end of the stream.
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Base128">
            <summary>
            A base-128 length prefix is applied to the data (efficient for short messages).
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Fixed32">
            <summary>
            A fixed-length (little-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Fixed32BigEndian">
            <summary>
            A fixed-length (big-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.MetaType">
            <summary>
            Represents a type at runtime for use with protobuf, allowing the field mappings (etc) to be defined
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.ToString">
            <summary>
            Get the name of the type being represented
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddSubType(System.Int32,System.Type)">
            <summary>
            Adds a known sub-type to the inheritance model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.GetSubtypes">
            <summary>
            Obtains the subtypes that are defined for the current type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
            <param name="beforeSerialize">The method (or null) called before serialization begins.</param>
            <param name="afterSerialize">The method (or null) called when serialization is complete.</param>
            <param name="beforeDeserialize">The method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
            <param name="afterDeserialize">The method (or null) called when deserialization is complete.</param>
            <returns>The set of callbacks.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.String,System.String,System.String,System.String)">
            <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
            <param name="beforeSerialize">The name of the method (or null) called before serialization begins.</param>
            <param name="afterSerialize">The name of the method (or null) called when serialization is complete.</param>
            <param name="beforeDeserialize">The name of the method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
            <param name="afterDeserialize">The name of the method (or null) called when deserialization is complete.</param>
            <returns>The set of callbacks.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.ThrowIfFrozen">
            <summary>
            Throws an exception if the type has been made immutable
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>        
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String)">
            <summary>
            Adds a member (by name) to the MetaType, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.String)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>     
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetSurrogate(System.Type)">
            <summary>
            Performs serialization of this type via a surrogate; all
            other serialization options are ignored and handled
            by the surrogate's configuration.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.String[])">
            <summary>
            Adds a set of members (by name) to the MetaType
            </summary>     
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Object)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>        
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Type,System.Type)">
            <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String,System.Type,System.Type)">
            <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.BaseType">
            <summary>
            Gets the base-type for this type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.IncludeSerializerMethod">
            <summary>
            When used to compile a model, should public serialization/deserialzation methods
            be included for this type?
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.AsReferenceDefault">
            <summary>
            Should this type be treated as a reference by default?
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.HasCallbacks">
            <summary>
            Indicates whether the current type has defined callbacks 
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.HasSubtypes">
            <summary>
            Indicates whether the current type has defined subtypes
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Callbacks">
            <summary>
            Returns the set of callbacks defined for this type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Type">
            <summary>
            The runtime type that the meta-type represents
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.UseConstructor">
            <summary>
            Gets or sets whether the type should use a parameterless constructor (the default),
            or whether the type should skip the constructor completely. This option is not supported
            on compact-framework.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.ConstructType">
            <summary>
            The concrete type to create when a new instance of this type is needed; this may be useful when dealing
            with dynamic proxies, or with interface-based APIs
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Item(System.Int32)">
            <summary>
            Returns the ValueMember that matchs a given field number, or null if not found
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Item(System.Reflection.MemberInfo)">
            <summary>
            Returns the ValueMember that matchs a given member (property/field), or null if not found
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.EnumPassthru">
            <summary>
            Gets or sets a value indicating that an enum should be treated directly as an int/short/etc, rather
            than enforcing .proto enum rules. This is useful *in particul* for [Flags] enums.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.CallbackSet">
            <summary>
            Represents the set of serialization callbacks to be used when serializing/deserializing a type.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.BeforeSerialize">
            <summary>Called before serializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.BeforeDeserialize">
            <summary>Called before deserializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.AfterSerialize">
            <summary>Called after serializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.AfterDeserialize">
            <summary>Called after deserializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.NonTrivial">
            <summary>
            True if any callback is set, else False
            </summary>
        </member>
        <member name="T:ProtoBuf.Extensible">
            <summary>
            Simple base class for supporting unexpected fields allowing
            for loss-less round-tips/merge, even if the data is not understod.
            The additional fields are (by default) stored in-memory in a buffer.
            </summary>
            <remarks>As an example of an alternative implementation, you might
            choose to use the file system (temporary files) as the back-end, tracking
            only the paths [such an object would ideally be IDisposable and use
            a finalizer to ensure that the files are removed].</remarks>
            <seealso cref="T:ProtoBuf.IExtensible"/>
        </member>
        <member name="M:ProtoBuf.Extensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:ProtoBuf.Extensible.GetExtensionObject(ProtoBuf.IExtension@,System.Boolean)">
            <summary>
            Provides a simple, default implementation for <see cref="T:ProtoBuf.IExtension">extension</see> support,
            optionally creating it if it does not already exist. Designed to be called by
            classes implementing <see cref="T:ProtoBuf.IExtensible"/>.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <param name="extensionObject">The extension field to check (and possibly update).</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The type of the value to append.</typeparam>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.Meta.TypeModel,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="model">The model that represents the data.</param>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="T:Arch.Framework.Utility.DbValueHelper">
            <summary>
            数据表返回值帮助类,用于读取数据流中的一个基本类型值,对象或对象集合
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.DbValueHelper.GetValue``1(System.Data.IDataReader,System.String)">
            <summary>
            获取存储在由columnName指定的列中的数据,并转换为基本类型.如果类型不匹配或列不存在,则抛出异常.
            </summary>
            <typeparam name="T">基本类型只能为基元类型,String,DateTime,Decimal,TimeSpan,Byte[]其中之一</typeparam>
            <param name="dataReader">数据流</param>
            <param name="columnName">列名</param>
            <returns>获取的值</returns>
            <exception cref="T:System.ArgumentException">如果输入类型不为基本类型时,抛出异常.</exception>
        </member>
        <member name="M:Arch.Framework.Utility.DbValueHelper.GetValueOrDefault``1(System.Data.IDataReader,System.String)">
            <summary>
            获取存储在由columnName指定的列中的数据,并转换为基本类型.如果类型不匹配或列不存在,则返回基本类型的默认值.
            </summary>
            <typeparam name="T">基本类型只能为基元类型,String,DateTime,Decimal,TimeSpan,Byte[]其中之一</typeparam>
            <param name="dataReader">数据流</param>
            <param name="columnName">列明</param>
            <returns>获取的值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.DbValueHelper.GetValue``1(System.Data.IDataReader)">
            <summary>
            获取存储在该数据流中的一条记录,并转化为指定类型的对象.如果类型不匹配,则返回NULL
            </summary>
            <typeparam name="T">指定的类型</typeparam>
            <param name="dataReader">数据流</param>
            <returns>指定类型的对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.DbValueHelper.GetValues``1(System.Data.IDataReader)">
            <summary>
            获取数据流中指定类型的对象集合
            </summary>
            <typeparam name="T">指定的类型</typeparam>
            <param name="dataReader">数据流</param>
            <returns>指定类型的对象集合</returns>
        </member>
        <member name="M:Arch.Framework.Utility.DbValueHelper.GetValue``1(System.Data.DataRow,System.String)">
            <summary>
            获取存储在由columnName指定的列中的数据,并转换为基本类型.如果类型不匹配或列不存在,则抛出异常.
            </summary>
            <typeparam name="T">基本类型只能为基元类型,String,DateTime,Decimal,TimeSpan,Byte[]其中之一</typeparam>
            <param name="row">数据流</param>
            <param name="columnName">列名</param>
            <returns>获取的值</returns>
            <exception cref="T:System.ArgumentException">如果输入类型不为基本类型时,抛出异常.</exception>
        </member>
        <member name="M:Arch.Framework.Utility.DbValueHelper.GetValueOrDefault``1(System.Data.DataRow,System.String)">
            <summary>
            获取存储在由columnName指定的列中的数据,并转换为基本类型.如果类型不匹配或列不存在,则返回基本类型的默认值.
            </summary>
            <typeparam name="T">基本类型只能为基元类型,String,DateTime,Decimal,TimeSpan,Byte[]其中之一</typeparam>
            <param name="row">数据流</param>
            <param name="columnName">列名</param>
            <returns>获取的值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.DbValueHelper.GetValue``1(System.Data.DataRow)">
            <summary>
            获取存储在该数据流中的一条记录,并转化为指定类型的对象.如果类型不匹配,则返回NULL
            </summary>
            <typeparam name="T">指定的类型</typeparam>
            <param name="row">数据流</param>
            <returns>指定类型的对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.DbValueHelper.GetValues``1(System.Data.DataTable)">
            <summary>
            获取数据流中指定类型的对象集合
            </summary>
            <typeparam name="T">指定的类型</typeparam>
            <param name="table">数据流</param>
            <returns>指定类型的对象集合</returns>
        </member>
        <member name="M:Arch.Framework.Utility.DbValueHelper.ValidateType(System.Type)">
            <summary>
            验证类型是否为基本类型
            </summary>
            <param name="type">基本类型只能为基元类型,String,DateTime,Decimal,TimeSpan,Byte[]其中之一</param>
            <returns>返回Bool值,如果是基本类型,则返回true,否则返回false</returns>
        </member>
        <member name="M:Arch.Framework.Utility.DbValueHelper.GetValueOfDataReader``1(System.Data.IDataReader)">
            <summary>
            获取存储在该数据流中的一条记录,并转化为指定类型的对象.如果类型不匹配,则返回NULL
            </summary>
            <typeparam name="T">指定的类型</typeparam>
            <param name="dataReader">数据流</param>
            <returns>指定类型的对象</returns>
        </member>
        <member name="T:Arch.Framework.Utility.Serialize.XMLSerializer">
            <summary>
            XML序列化、反序列化工具类
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.Serialize.XMLSerializer.serializers">
            <summary>
            序列化器缓存
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.Serialize.XMLSerializer.xmlNs">
            <summary>
            一个空的命名空间
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.XMLSerializer.Deserialize``1(System.String)">
            <summary>
            从字符串中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的格式化字符串</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.XMLSerializer.Deserialize``1(System.IO.Stream)">
            <summary>
            从当前流中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的流</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.XMLSerializer.Deserialize``1(System.Byte[])">
            <summary>
            从当前字节串中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的字节串</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.XMLSerializer.DeserializeFromFile``1(System.String)">
            <summary>
            从文件中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="fileName">T类型的格式化文件</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.XMLSerializer.Serialize``1(``0)">
            <summary>
            将T类序列化为一个字符串
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <returns>T类型的格式化字符串</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.XMLSerializer.Serialize``1(``0,System.IO.Stream)">
            <summary>
            将T类序列化到一个流中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="destination">流</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.XMLSerializer.Serialize``1(``0,System.Byte[]@)">
            <summary>
            将T类序列化到一个字节序列中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="buf">字节序列</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.XMLSerializer.Serialize``1(``0,System.String)">
            <summary>
            将T类序列化到一个文件中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="fileName">输出的文件名</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.XMLSerializer.GetXmlSerializer(System.Type)">
            <summary>
            从缓存中获取一个XML序列化对象,如果没有,则创建,并添加到缓存中
            </summary>
            <returns>XML序列化对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.XMLSerializer.GetXmlNameSpace">
            <summary>
            获取一个空的命名空间
            </summary>
            <returns>空命名空间</returns>
        </member>
        <member name="T:Arch.Framework.Utility.Serialize.SerializeFactory">
            <summary>
            序列化对象工厂,根据用户输入或配置项创建序列化对象
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.SerializeFactory.GetSerializer">
            <summary>
            根据AppSettings.config中Serializer_Mode配置项创建序列化对象.不指定该项时,或指定方式不存在时,默认使用二进制序列化方式.
            </summary>
            <returns>序列化对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.SerializeFactory.GetSerializer(System.String)">
            <summary>
            根据用户指定的方式构造序列化对象
            </summary>
            <param name="mode">序列化方式</param>
            <returns>序列化对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.SerializeFactory.GetSerializer(Arch.Framework.Utility.Serialize.SerializeMethod)">
            <summary>
            根据用户指定的方式构造序列化对象
            </summary>
            <param name="mode">序列化方式</param>
            <returns>序列化对象</returns>
        </member>
        <member name="T:Arch.Framework.Utility.Serialize.NameValueSerializer">
            <summary>
            NameValue序列化、反序列化工具类
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.Serialize.NameValueSerializer.hashTypes">
            <summary>
            属性集合缓存
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.Serialize.NameValueSerializer.nvcSerializer">
            <summary>
            二进制序列化反序列化对象
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.NameValueSerializer.Deserialize``1(System.String)">
            <summary>
            从字符串中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的格式化字符串</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.NameValueSerializer.Deserialize``1(System.IO.Stream)">
            <summary>
            从当前流中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的流</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.NameValueSerializer.Deserialize``1(System.Byte[])">
            <summary>
            从当前字节串中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="source">T类型的字节串</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.NameValueSerializer.DeserializeFromFile``1(System.String)">
            <summary>
            从文件中反序列化一个T类型对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="fileName">T类型的格式化文件</param>
            <returns>T类型对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.NameValueSerializer.Serialize``1(``0)">
            <summary>
            将T类序列化为一个字符串
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <returns>T类型的格式化字符串</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.NameValueSerializer.Serialize``1(``0,System.IO.Stream)">
            <summary>
            将T类序列化到一个流中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="destination">流</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.NameValueSerializer.Serialize``1(``0,System.Byte[]@)">
            <summary>
            将T类序列化到一个字节序列中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="buf">字节序列</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.NameValueSerializer.Serialize``1(``0,System.String)">
            <summary>
            将T类序列化到一个文件中
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">T类型对象</param>
            <param name="fileName">输出的文件名</param>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.NameValueSerializer.ToNameValues``1(``0)">
            <summary>
            将平面实体对象转化成NameValueCollection对象
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="t">实体对象</param>
            <returns>NameValueCollection对象 </returns>        
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.NameValueSerializer.FromNameValues``1(System.Collections.Specialized.NameValueCollection)">
            <summary>
            将NameValueCollection对象转换成平面实体对象  
            </summary>
            <typeparam name="T">序列化、反序列化对象的类型</typeparam>
            <param name="data">NameValueCollection对象</param>
            <returns>实体对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.Serialize.NameValueSerializer.GetProperties(System.Type)">
            <summary>
            从缓存中获取一个类型的属性集合，如果没有，则创建，并添加到缓存中，用于提高应用程序性能
            </summary>
            <returns>缓存集合</returns>
        </member>
        <member name="T:ProtoBuf.SerializationContext">
            <summary>
            Additional information about a serialization operation
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.Context">
            <summary>
            Gets or sets a user-defined object containing additional information about this serialization/deserialization operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.Default">
            <summary>
            A default SerializationContext, with minimal information.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag. A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(System.Object)">
            <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(ProtoBuf.ProtoMemberAttribute)">
            <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.#ctor(System.Int32)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Name">
            <summary>
            Gets or sets the original name defined in the .proto; not used
            during serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.DataFormat">
            <summary>
            Gets or sets the data-format to be used when encoding this value.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Tag">
            <summary>
            Gets the unique tag used to identify this member within the type.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.IsRequired">
            <summary>
            Gets or sets a value indicating whether this member is mandatory.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.IsPacked">
            <summary>
            Gets a value indicating whether this member is packed.
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Options">
            <summary>
            Gets or sets a value indicating whether this member is packed (lists/arrays).
            </summary>
        </member>
        <member name="T:ProtoBuf.MemberSerializationOptions">
            <summary>
            Additional (optional) settings that control serialization of members
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.None">
            <summary>
            Default; no additional options
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.Packed">
            <summary>
            Indicates that repeated elements should use packed (length-prefixed) encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.Required">
            <summary>
            Indicates that the given item is required
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.AsReference">
            <summary>
            Enables full object-tracking/full-graph support
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoPartialMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag and MemberName. This allows ProtoMemberAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoPartialMemberAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
            <param name="memberName">Specifies the member to be serialized.</param>
        </member>
        <member name="P:ProtoBuf.ProtoPartialMemberAttribute.MemberName">
            <summary>
            The name of the member to be serialized.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoException">
            <summary>
            Indicates an error during serialization/deserialization of a proto stream.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.String)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.String,System.Exception)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoContractAttribute">
            <summary>
            Indicates that a type is defined for protocol-buffer serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.Name">
            <summary>
            Gets or sets the defined name of the type.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFirstTag">
            <summary>
            Gets or sets the fist offset to use with implicit field tags;
            only uesd if ImplicitFields is set.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.UseProtoMembersOnly">
            <summary>
            If specified, alternative contract markers (such as markers for XmlSerailizer or DataContractSerializer) are ignored.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFields">
            <summary>
            Gets or sets the mechanism used to automatically infer field tags
            for members. This option should be used in advanced scenarios only.
            Please review the important notes against the ImplicitFields enumeration.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromName">
            <summary>
            Enables/disables automatic tag generation based on the existing name / order
            of the defined members. This option is not used for members marked
            with ProtoMemberAttribute, as intended to provide compatibility with
            WCF serialization. WARNING: when adding new fields you must take
            care to increase the Order for new elements, otherwise data corruption
            may occur.
            </summary>
            <remarks>If not explicitly specified, the default is assumed from <see cref="P:ProtoBuf.Serializer.GlobalOptions.InferTagFromName"/>.</remarks>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromNameHasValue">
            <summary>
            Has a InferTagFromName value been explicitly set? if not, the default from the type-model is assumed.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.DataMemberOffset">
            <summary>
            Specifies an offset to apply to [DataMember(Order=...)] markers;
            this is useful when working with mex-generated classes that have
            a different origin (usually 1 vs 0) than the original data-contract.
            
            This value is added to the Order of each member.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.SkipConstructor">
            <summary>
            If true, the constructor for the type is bypassed during deserialization, meaning any field initializers
            or other initialization code is skipped.
            </summary>
        </member>
        <member name="T:ProtoBuf.BufferExtension">
            <summary>
            Provides a simple buffer-based implementation of an <see cref="T:ProtoBuf.IExtension">extension</see> object.
            </summary>
        </member>
        <member name="T:Arch.Framework.Utility.DataTableExport">
            <summary>
            DataTable导出为Excel和CSV的工具类,支持Web和App两种应用程序
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.DataTableExport.response">
            <summary>
            自ASP.NET操作的HTTP响应信息
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.DataTableExport.appType">
            <summary>
            应用程序类型
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.DataTableExport.#ctor">
            <summary>
            实例化,默认应用程序类型为:Web
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.DataTableExport.#ctor(Arch.Framework.Utility.DataTableExport.AppType)">
            <summary>
            根据用户指定的应用程序类型实例化导出类
            </summary>
            <param name="appType">应用程序类型</param>
        </member>
        <member name="M:Arch.Framework.Utility.DataTableExport.ExportDetails(System.Data.DataTable,Arch.Framework.Utility.DataTableExport.ExportFormat,System.String)">
            <summary>
            按照默认列的顺序导出DataTable中所有数据到指定类型的文件中
            </summary>
            <param name="DetailsTable">数据源</param>
            <param name="FormatType">导出类型CSV or EXCEL</param>
            <param name="FileName">文件名</param>
        </member>
        <member name="M:Arch.Framework.Utility.DataTableExport.ExportDetails(System.Data.DataTable,System.Int32[],Arch.Framework.Utility.DataTableExport.ExportFormat,System.String)">
            <summary>
            按照用户选定的列以及顺序导出DataTable中所有数据到指定类型的文件中
            </summary>
            <param name="DetailsTable">数据源</param>
            <param name="ColumnList">列数组</param>
            <param name="FormatType">导出类型CSV or EXCEL</param>
            <param name="FileName">文件名</param>
        </member>
        <member name="M:Arch.Framework.Utility.DataTableExport.ExportDetails(System.Data.DataTable,System.Int32[],System.String[],Arch.Framework.Utility.DataTableExport.ExportFormat,System.String)">
            <summary>
            按照用户指定的列，顺序以及按顺序对应的表头导出DataTable中所有数据到指定类型的文件中
            </summary>
            <param name="DetailsTable">数据源</param>
            <param name="ColumnList">列数组</param>
            <param name="Headers">表头</param>
            <param name="FormatType">导出类型CSV or EXCEL</param>
            <param name="FileName">文件名</param>
        </member>
        <member name="M:Arch.Framework.Utility.DataTableExport.ExportWithXSLTWeb(System.Data.DataSet,System.String[],System.String[],Arch.Framework.Utility.DataTableExport.ExportFormat,System.String)">
            <summary>
             Web程序导出方法
            </summary>
            <param name="dsExport">数据源</param>
            <param name="sHeaders">表头</param>
            <param name="sFileds">列</param>
            <param name="FormatType">导出类型CSV or EXCEL</param>
            <param name="FileName">文件名</param>
        </member>
        <member name="M:Arch.Framework.Utility.DataTableExport.ExportWithXSLTWindows(System.Data.DataSet,System.String[],System.String[],Arch.Framework.Utility.DataTableExport.ExportFormat,System.String)">
            <summary>
             WinFrom程序导出方法
            </summary>
            <param name="dsExport">数据源</param>
            <param name="sHeaders">表头</param>
            <param name="sFileds">列</param>
            <param name="FormatType">导出类型CSV or EXCEL</param>
            <param name="FileName">文件名</param>
        </member>
        <member name="M:Arch.Framework.Utility.DataTableExport.CreateStylesheet(System.Xml.XmlTextWriter,System.String[],System.String[],Arch.Framework.Utility.DataTableExport.ExportFormat)">
            <summary>
            设置导出样式
            </summary>
            <param name="writer"></param>
            <param name="sHeaders"></param>
            <param name="sFileds"></param>
            <param name="FormatType"></param>
        </member>
        <member name="M:Arch.Framework.Utility.DataTableExport.ReplaceSpclChars(System.String)">
            <summary>
            设置过滤符号
            </summary>
            <param name="fieldName">文件名</param>
            <returns></returns>
        </member>
        <member name="T:Arch.Framework.Utility.DataTableExport.ExportFormat">
            <summary>
            导出类型
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.DataTableExport.ExportFormat.CSV">
            <summary>
            CSV文件
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.DataTableExport.ExportFormat.Excel">
            <summary>
            Excel文件
            </summary>
        </member>
        <member name="T:Arch.Framework.Utility.DataTableExport.AppType">
            <summary>
            应用程序类型
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.DataTableExport.AppType.Web">
            <summary>
            Web程序
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.DataTableExport.AppType.Win">
            <summary>
            桌面程序
            </summary>
        </member>
        <member name="T:ProtoBuf.ImplicitFields">
            <summary>
            Specifies the method used to infer field tags for members of the type
            under consideration. Tags are deduced using the invariant alphabetic
            sequence of the members' names; this makes implicit field tags very brittle,
            and susceptible to changes such as field names (normally an isolated
            change).
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.None">
            <summary>
            No members are serialized implicitly; all members require a suitable
            attribute such as [ProtoMember]. This is the recmomended mode for
            most scenarios.
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.AllPublic">
            <summary>
            Public properties and fields are eligible for implicit serialization;
            this treats the public API as a contract. Ordering beings from ImplicitFirstTag.
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.AllFields">
            <summary>
            Public and non-public fields are eligible for implicit serialization;
            this acts as a state/implementation serializer. Ordering beings from ImplicitFirstTag.
            </summary>
        </member>
        <member name="T:Arch.Framework.Utility.CookieHelper">
            <summary>
            Cookie扩展类
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.CookieHelper.serializer">
            <summary>
            序列化工具类
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.CookieHelper.AppendCookie(System.String,System.Object,System.Int32,System.String,System.String[])">
            <summary>
            存储Cookie
            </summary>
            <param name="name">Coookies名称</param>
            <param name="value">对象</param>
            <param name="expiredays">Cookie有效天数</param>
            <param name="domain">与cookie关联的域</param>
            <param name="path">Cookie路径</param>
        </member>
        <member name="M:Arch.Framework.Utility.CookieHelper.GetCookie(System.String)">
            <summary>
            获得Cookie
            </summary>
            <param name="name">Cookie名称</param>
            <returns>对象</returns>
        </member>
        <member name="T:Arch.Framework.Utility.StringExtension">
            <summary>
            string 扩展方法类
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.StringExtension.ToSpell(System.String,System.String)">
            <summary>
            汉字转换为拼音（拼音首字符大写）
            </summary>
            <param name="hzString">汉字</param>
            <param name="splitChar">指定的分隔符，默认为空字符串</param>
            <returns></returns>
        </member>
        <member name="M:Arch.Framework.Utility.StringExtension.IsNumber(System.String)">
            <summary>
            判断字符串是否数字
            </summary>
            <param name="source">输入的字符串</param>
            <returns>全部为数字时返回true，否则返回false</returns>
        </member>
        <member name="M:Arch.Framework.Utility.StringExtension.ToTraditionalChinese(System.String)">
            <summary>
            取得繁体字符传
            </summary>
            <param name="inputString">输入字符串</param>
            <returns>输出字符串</returns>     
        </member>
        <member name="M:Arch.Framework.Utility.StringExtension.IsJustIncludeNumericOrLetter(System.String)">
            <summary>
            验证字符串只包含数字或字母（正则表达式）（true = 只包含数字或字母, false = 还有其他字符）
            </summary>
            <param name="validatedString">被验证的字符串</param>
            <returns>true = 只包含数字或字母, false = 还有其他字符</returns>       
        </member>
        <member name="M:Arch.Framework.Utility.StringExtension.IsDateTime(System.String)">
            <summary>
            验证字符串是时间日期(true = 字符串是时间日期, false = 字符串不是时间日期)
            </summary>
            <param name="validatedString">被验证的字符串</param>
            <returns>true = 字符串是时间日期, false = 字符串不是时间日期</returns>       
        </member>
        <member name="M:Arch.Framework.Utility.StringExtension.IsIncludeChinese(System.String)">
            <summary>
            验证字符串包含中文字符(true = 包含, false = 不包含)
            </summary>
            <param name="validatedString">被验证的字符串</param>
            <returns>true = 包含, false = 不包含</returns>       
        </member>
        <member name="M:Arch.Framework.Utility.StringExtension.IsAllOfChinese(System.String)">
            <summary>
            验证字符串全部是中文字符(true = 全部是中文字符, false = 包含非中文字符)
            </summary>
            <param name="validatedString">被验证的字符串</param>
            <returns>true = 包含, false = 不包含</returns>       
        </member>
        <member name="M:Arch.Framework.Utility.StringExtension.ChineseCount(System.String)">
            <summary>
            获取字符串中中文字符的数量
            </summary>
            <param name="inputString">输入字符串</param>
            <returns>中文字符的数量</returns>       
        </member>
        <member name="T:ProtoBuf.WireType">
            <summary>
            Indicates the encoding used to represent an individual value in a protobuf stream
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.None">
            <summary>
            Represents an error condition
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Variant">
            <summary>
            Base-128 variant-length encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Fixed64">
            <summary>
            Fixed-length 8-byte encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.String">
            <summary>
            Length-variant-prefixed encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.StartGroup">
            <summary>
            Indicates the start of a group
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.EndGroup">
            <summary>
            Indicates the end of a group
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Fixed32">
            <summary>
            Fixed-length 4-byte encoding
            </summary>10
        </member>
        <member name="F:ProtoBuf.WireType.SignedVariant">
            <summary>
            This is not a formal wire-type in the "protocol buffers" spec, but
            denotes a variant integer that should be interpreted using
            zig-zag semantics (so -ve numbers aren't a significant overhead)
            </summary>
        </member>
        <member name="T:Arch.Framework.Utility.MobileHelper">
            <summary>
            手机号码工具
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.MobileHelper.IsValidate(System.String)">
            <summary>
            验证手机号是否合法（中国手机号码）
            </summary>
            <param name="mobile">手机号</param>
            <returns>合法返回true,不合法返回false</returns>
        </member>
        <member name="T:Arch.Framework.Utility.ConvertHelper">
            <summary>
            类型转换
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToTOrF(System.Boolean)">
            <summary>
            转换Bool值为F或T
            </summary>
            <param name="source">源数据</param>
            <returns>source为true时返回T，否则返回F</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToWeekInt32``1(``0)">
            <summary>
            转换Object为星期值
            </summary>
            <typeparam name="T">输入源的类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回星期几</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToWeekInt32(System.DayOfWeek)">
            <summary>
            转换DayOfWeek为星期几，其中Sunday返回7
            </summary>
            <param name="week">DayOfWeek值</param>
            <returns>返回星期几</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToNullableDateTime``1(``0)">
            <summary>
            转换Object为DateTime？
            </summary>
            <typeparam name="T">参数类型</typeparam>
            <param name="source">需转换的参数</param>
            <returns>返回时间值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToBool``1(``0)">
            <summary>
            转换字符串为true、false
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回true或false</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToEnum``2(``0)">
            <summary>
            源数据转换为指定的枚举类型
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <typeparam name="V">目标枚举类型</typeparam>
            <param name="source">源数据</param>
            <returns>当源数据可转换为目标枚举类型时返回转换后的枚举值，否则返回枚举默认值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToNullabelInt32``1(``0)">
            <summary>
            转换数据为int?型
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回int?值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToByte``1(``0)">
            <summary>
            转换数据为byte型
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回byte值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToRoundInt32``1(``0)">
            <summary>
            四舍五入
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回四舍五入后的值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToNullableDecimal``1(``0)">
            <summary>
            转换数据为decimal?型
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回转换后的decimal?值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToDecimal``1(``0)">
            <summary>
            转换数据为decimal类型
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回转换后的decimal值，当源数据不能转换为decimal时返回0</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToInt32``1(``0)">
            <summary>
            转换数据为int型
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回转换后的int值，当不能转换为int值时返回0</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToDateTime``1(``0)">
            <summary>
            转换数据为DateTime类型
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回转换后的DateTime，当不能转换为DateTime时，返回default( DateTime )</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToFloat``1(``0)">
            <summary>
            转换源数据为float类型
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回转换后的float值，当不能转换为float时返回0f</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToString``1(``0)">
            <summary>
            转换源数据为字符串
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回转换后的字符串</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToENCultureInfoDateTime(System.DateTime)">
            <summary>
            得到日期的英文格式 "MMM-dd-yyyy"
            </summary>
            <param name="date">源数据</param>
            <returns>返回日期的英文歌是</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToZHCultureInfoDateTime(System.DateTime)">
            <summary>
            格式化时间字符串 "yyyy-MM-dd"
            </summary>
            <param name="date">源数据</param>
            <returns>返回格式化后数据</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToTrimString``1(``0)">
            <summary>
            去除字符串空格
            </summary>
            <typeparam name="T">源数据类型</typeparam>
            <param name="source">源数据</param>
            <returns>返回去除空格的字符串</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToEntity``2(``0)">
            <summary>
            对象类型转换 TSource->TResult
            </summary>
            <typeparam name="TSource">源对象类型</typeparam>
            <typeparam name="TResult">目标对象类型</typeparam>
            <param name="source">源对象</param>
            <returns>转换后的目标对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToList``2(System.Collections.Generic.List{``0})">
            <summary>
            转换List &lt;TSource&gt; -> List&lt;TResult&gt;
            </summary>
            <typeparam name="TSource">源对象类型</typeparam>
            <typeparam name="TResult">目标对象类型</typeparam>
            <param name="list">源对象List</param>
            <returns>目标对象List</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ConvertHelper.ToFormatedDateTimeString(System.DateTime,System.String,System.String)">
            <summary>
            返回格式化的日期字符串(format格式需与cultureinfo对应)
            </summary>
            <param name="dt">日期</param>
            <param name="cultureInforName">区域文化名称</param>
            <param name="format">格式化字符串</param>
            <returns>格式化的日期字符串</returns>
        </member>
        <member name="T:ProtoBuf.Meta.ValueMember">
            <summary>
            Represents a member (property/field) that is mapped to a protobuf field
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Type,System.Int32,System.Reflection.MemberInfo,System.Type,System.Type,System.Type,ProtoBuf.DataFormat,System.Object)">
            <summary>
            Creates a new ValueMember instance
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Int32,System.Type,System.Type,System.Type,ProtoBuf.DataFormat)">
            <summary>
            Creates a new ValueMember instance
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.SetSpecified(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Specifies methods for working with optional data members.
            </summary>
            <param name="getSpecified">Provides a method (null for none) to query whether this member should
            be serialized; it must be of the form "bool {Method}()". The member is only serialized if the
            method returns true.</param>
            <param name="setSpecified">Provides a method (null for none) to indicate that a member was
            deserialized; it must be of the form "void {Method}(bool)", and will be called with "true"
            when data is found.</param>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.FieldNumber">
            <summary>
            The number that identifies this member in a protobuf stream
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.Member">
            <summary>
            Gets the member (field/property) which this member relates to.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.ItemType">
            <summary>
            Within a list / array / etc, the type of object for each item in the list (especially useful with ArrayList)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.MemberType">
            <summary>
            The underlying type of the member
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DefaultType">
            <summary>
            For abstract types (IList etc), the type of concrete object to create (if required)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.ParentType">
            <summary>
            The type the defines the member
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DefaultValue">
            <summary>
            The default value of the item (members with this value will not be serialized)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DataFormat">
            <summary>
            Specifies the rules used to process the field; this is used to determine the most appropriate
            wite-type, but also to describe subtypes <i>within</i> that wire-type (such as SignedVariant)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsStrict">
            <summary>
            Indicates whether this field should follow strict encoding rules; this means (for example) that if a "fixed32"
            is encountered when "variant" is defined, then it will fail (throw an exception) when parsing. Note that
            when serializing the defined type is always used.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsPacked">
            <summary>
            Indicates whether this field should use packed encoding (which can save lots of space for repeated primitive values).
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsRequired">
            <summary>
            Indicates whether this field is mandatory.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.Name">
            <summary>
            Gets the logical name for this member in the schema (this is not critical for binary serialization, but may be used
            when inferring a schema).
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.SubType">
            <summary>
            Represents an inherited type in a type hierarchy.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.SubType.#ctor(System.Int32,ProtoBuf.Meta.MetaType)">
            <summary>
            Creates a new SubType instance.
            </summary>
            <param name="fieldNumber">The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.</param>
            <param name="derivedType">The sub-type to be considered.</param>
        </member>
        <member name="P:ProtoBuf.Meta.SubType.FieldNumber">
            <summary>
            The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.SubType.DerivedType">
            <summary>
            The sub-type to be considered.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoBeforeSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before serialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoAfterSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after serialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoBeforeDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before deserialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoAfterDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after deserialization.</summary>
        </member>
        <member name="T:ProtoBuf.DataFormat">
            <summary>
            Sub-format to use when serializing/deserializing data
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.Default">
            <summary>
            Uses the default encoding for the data-type.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.ZigZag">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that zigzag variant encoding will be used. This means that values
            with small magnitude (regardless of sign) take a small amount
            of space to encode.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.TwosComplement">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that two's-complement variant encoding will be used.
            This means that any -ve number will take 10 bytes (even for 32-bit),
            so should only be used for compatibility.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.FixedSize">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that a fixed amount of space will be used.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.Group">
            <summary>
            When applied to a sub-message, indicates that the value should be treated
            as group-delimited.
            </summary>
        </member>
        <member name="T:Arch.Framework.Utility.XMLProcess">
            <summary>
            XML文件处理静态类
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcess.XMLLoad(System.String)">
            <summary>
            导入XML文件
            </summary>
            <param name="strPath">XML文件路径</param>
            <returns>XML文档对象</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcess.Read(System.String,System.String)">
            <summary>
            读取指定路径和节点的串联值
            </summary>
            <param name="path">路径</param>
            <param name="node">符合XPath表达式的节点名</param>
            <returns>指定节点的值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcess.Read(System.String,System.String,System.String)">
            <summary>
            读取指定路径和节点的属性值
            </summary>
            <param name="path">路径</param>
            <param name="node">符合XPath表达式的节点名</param>
            <param name="attribute">属性名，非空时返回该属性值，否则返回串联值</param>
            <returns>指定节点的值或属性值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcess.Insert(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            插入数据
            </summary>
            <param name="path">路径</param>
            <param name="node">符合XPath表达式的节点名</param>
            <param name="element">元素名，非空时插入新元素，否则在该元素中插入属性</param>
            <param name="attribute">属性名，非空时插入该元素属性值，否则插入元素值</param>
            <param name="value">值</param>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcess.Insert(System.String,System.String,System.String,System.String[][])">
            <summary>
            插入数据
            </summary>
            <param name="path">路径</param>
            <param name="node">符合XPath表达式的节点名</param>
            <param name="element">元素名，非空时插入新元素，否则在该元素中插入属性</param>
            <param name="strList">strList是一个二维数组，它的值是由xml属性名和值组成的</param>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcess.Update(System.String,System.String,System.String)">
            <summary>
            修改指定节点的数据
            </summary>
            <param name="path">路径</param>
            <param name="node">符合XPath表达式的节点名</param>
            <param name="value">值</param>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcess.Update(System.String,System.String,System.String,System.String)">
            <summary>
            修改指定节点的属性值(静态)
            </summary>
            <param name="path">路径</param>
            <param name="node">符合XPath表达式的节点名</param>
            <param name="attribute">属性名，非空时修改该节点属性值，否则修改节点值</param>
            <param name="value">值</param>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcess.Delete(System.String,System.String)">
            <summary>
            删除节点值
            </summary>
            <param name="path">路径</param>
            <param name="node">符合XPath表达式的节点名</param>
        </member>
        <member name="M:Arch.Framework.Utility.XMLProcess.Delete(System.String,System.String,System.String)">
            <summary>
            删除数据
            </summary>
            <param name="path">路径</param>
            <param name="node">符合XPath表达式的节点名</param>
            <param name="attribute">属性名，非空时删除该节点属性值，否则删除节点值</param>
        </member>
        <member name="T:ProtoBuf.ProtoWriter">
            <summary>
            Represents an output stream for writing protobuf data.
            
            Why is the API backwards (static methods with writer arguments)?
            See: http://marcgravell.blogspot.com/2010/03/last-will-be-first-and-first-will-be.html
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteObject(System.Object,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Write an encapsulated sub-object, using the supplied unique key (reprasenting a type).
            </summary>
            <param name="value">The object to write.</param>
            <param name="key">The key that uniquely identifies the type within the model.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteRecursionSafeObject(System.Object,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Write an encapsulated sub-object, using the supplied unique key (reprasenting a type) - but the
            caller is asserting that this relationship is non-recursive; no recursion check will be
            performed.
            </summary>
            <param name="value">The object to write.</param>
            <param name="key">The key that uniquely identifies the type within the model.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteFieldHeader(System.Int32,ProtoBuf.WireType,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a field-header, indicating the format of the next data we plan to write.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],ProtoBuf.ProtoWriter)">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],System.Int32,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.StartSubItem(System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Indicates the start of a nested record.
            </summary>
            <param name="instance">The instance to write.</param>
            <param name="writer">The destination.</param>
            <returns>A token representing the state of the stream; this token is given to EndSubItem.</returns>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoWriter)">
            <summary>
            Indicates the end of a nested record.
            </summary>
            <param name="token">The token obtained from StartubItem.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
            <summary>
            Creates a new writer against a stream
            </summary>
            <param name="dest">The destination stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to serialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Close">
            <summary>
            Flushes data to the underlying stream, and releases any resources. The underlying stream is *not* disposed
            by this operation.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Flush(ProtoBuf.ProtoWriter)">
            <summary>
            Writes any buffered data (if possible) to the underlying stream.
            </summary>
            <param name="writer">The writer to flush</param>
            <remarks>It is not always possible to fully flush, since some sequences
            may require values to be back-filled into the byte-stream.</remarks>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt32Variant(System.UInt32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteString(System.String,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a string to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt64(System.UInt64,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt64(System.Int64,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt32(System.UInt32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt16(System.Int16,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt16(System.UInt16,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteByte(System.Byte,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteSByte(System.SByte,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt32(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteDouble(System.Double,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a double-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteSingle(System.Single,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a single-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.ThrowEnumException(ProtoBuf.ProtoWriter,System.Object)">
            <summary>
            Throws an exception indicating that the given enum cannot be mapped to a serialized value.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBoolean(System.Boolean,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a boolean to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.AppendExtensionData(ProtoBuf.IExtensible,ProtoBuf.ProtoWriter)">
            <summary>
            Copies any extension data stored for the instance to the underlying stream
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.SetPackedField(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Used for packed encoding; indicates that the next field should be skipped rather than
            a field header written. Note that the field number must match, else an exception is thrown
            when the attempt is made to write the (incorrect) field. The wire-type is taken from the
            subsequent call to WriteFieldHeader. Only primitive types can be packed.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.SetRootObject(System.Object)">
            <summary>
            Specifies a known root object to use during reference-tracked serialization
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoWriter.Context">
            <summary>
            Addition information about this serialization operation.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoReader">
            <summary>
            A stateful reader, used to read a protobuf stream. Typical usage would be (sequentially) to call
            ReadFieldHeader and (after matching the field) an appropriate Read* method.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
        </member>
        <member name="M:ProtoBuf.ProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext,System.Int32)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
            <param name="length">The number of bytes to read, or -1 to read until the end of the stream</param>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Dispose">
            <summary>
            Releases resources used by the reader, but importantly <b>does not</b> Dispose the 
            underlying stream; in many typical use-cases the stream is used for different
            processes, so it is assumed that the consumer will Dispose their stream separately.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt32">
            <summary>
            Reads an unsigned 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt16">
            <summary>
            Reads a signed 16-bit integer from the stream: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt16">
            <summary>
            Reads an unsigned 16-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadByte">
            <summary>
            Reads an unsigned 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadSByte">
            <summary>
            Reads a signed 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt32">
            <summary>
            Reads a signed 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt64">
            <summary>
            Reads a signed 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadString">
            <summary>
            Reads a string from the stream (using UTF8); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ThrowEnumException(System.Type,System.Int32)">
            <summary>
            Throws an exception indication that the given value cannot be mapped to an enum.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadDouble">
            <summary>
            Reads a double-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadObject(System.Object,System.Int32,ProtoBuf.ProtoReader)">
            <summary>
            Reads (merges) a sub-message from the stream, internally calling StartSubItem and EndSubItem, and (in between)
            parsing the message in accordance with the model associated with the reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoReader)">
            <summary>
            Makes the end of consuming a nested message in the stream; the stream must be either at the correct EndGroup
            marker, or all fields of the sub-message must have been consumed (in either case, this means ReadFieldHeader
            should return zero)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.StartSubItem(ProtoBuf.ProtoReader)">
            <summary>
            Begins consuming a nested message in the stream; supported wire-types: StartGroup, String
            </summary>
            <remarks>The token returned must be help and used when callining EndSubItem</remarks>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadFieldHeader">
            <summary>
            Reads a field header from the stream, setting the wire-type and retuning the field number. If no
            more fields are available, then 0 is returned. This methods respects sub-messages.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.TryReadFieldHeader(System.Int32)">
            <summary>
            Looks ahead to see whether the next field in the stream is what we expect
            (typically; what we've just finished reading - for example ot read successive list items)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Hint(ProtoBuf.WireType)">
            <summary>
            Compares the streams current wire-type to the hinted wire-type, updating the reader if necessary; for example,
            a Variant may be updated to SignedVariant. If the hinted wire-type is unrelated then no change is made.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Assert(ProtoBuf.WireType)">
            <summary>
            Verifies that the stream's current wire-type is as expected, or a specialized sub-type (for example,
            SignedVariant) - in which case the current wire-type is updated. Otherwise an exception is thrown.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.SkipField">
            <summary>
            Discards the data for the current field.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt64">
            <summary>
            Reads an unsigned 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadSingle">
            <summary>
            Reads a single-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadBoolean">
            <summary>
            Reads a boolean value from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
            <returns></returns>
        </member>
        <member name="M:ProtoBuf.ProtoReader.AppendBytes(System.Byte[],ProtoBuf.ProtoReader)">
            <summary>
            Reads a byte-sequence from the stream, appending them to an existing byte-sequence (which can be null); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.TryReadUInt32Variant(System.IO.Stream,System.UInt32@)">
            <returns>The number of bytes consumed; 0 if no data available</returns>
        </member>
        <member name="M:ProtoBuf.ProtoReader.AppendExtensionData(ProtoBuf.IExtensible)">
            <summary>
            Copies the current field into the instance as extension data
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.HasSubValue(ProtoBuf.WireType,ProtoBuf.ProtoReader)">
            <summary>
            Indicates whether the reader still has data remaining in the current sub-item,
            additionally setting the wire-type for the next field if there is more data.
            This is used when decoding packed data.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.NoteObject(System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Utility method, not intended for public use; this helps maintain the root object is complex scenarios
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.FieldNumber">
            <summary>
            Gets the number of the field being processed.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.WireType">
            <summary>
            Indicates the underlying proto serialization format on the wire.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Context">
            <summary>
            Addition information about this deserialization operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Position">
            <summary>
            Returns the position of the current reader (note that this is not necessarily the same as the position
            in the underlying stream, if multiple readers are used on the same stream)
            </summary>
        </member>
        <member name="T:Arch.Framework.Utility.IPHelper">
            <summary>
            IP地址工具
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.IPHelper.GetClientIP">
            <summary>
            获取客户端的地址,获取顺序1.HTTP_X_FORWARDED_FOR;2.REMOTE_ADDR;3.UserHostAddress
            </summary>
            <returns>客户端IP</returns>
        </member>
        <member name="M:Arch.Framework.Utility.IPHelper.Compare(System.String,System.String)">
            <summary>
            比较IP地址大小
            </summary>
            <param name="ipAddress1">IP地址1</param>
            <param name="ipAddress2">IP地址2</param>
            <returns>返回比较结果，1大于、0等于、-1小于</returns>
        </member>
        <member name="M:Arch.Framework.Utility.IPHelper.IsInRange(System.String,System.String,System.String)">
            <summary>
            IP地址是否在地址段的范围内
            </summary>
            <param name="ipAddress">IP地址</param>
            <param name="lowerRange">地址段的下限</param>
            <param name="upperRange">地址段的上限</param>
            <returns>返回是否在范围地址段内的bool值</returns>
        </member>
        <member name="M:Arch.Framework.Utility.IPHelper.Ip2Long(System.String)">
            <summary>
            将字符串形式的IP地址(如:172.16.145.40)转化为一个长整形(如:1034938398)
            </summary>
            <param name="ipStr">IP地址</param>
            <returns>长整形的IP</returns>
        </member>
        <member name="T:Arch.Framework.Utility.CodeTimer">
            <summary>
            代码执行时间工具
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.CodeTimer.#cctor">
            <summary>
            静态构造函数，对Time方法预热
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.CodeTimer.Time(System.String,System.Int32,Arch.Framework.Utility.CodeTimer.ActionDelegate)">
            <summary>
            获取方法执行时间
            </summary>
            <param name="name">显示的名称</param>
            <param name="iteration">循环次数</param>
            <param name="action">需测试的方法</param>
            <returns>方法执行时间信息</returns>
        </member>
        <member name="M:Arch.Framework.Utility.CodeTimer.GetCurrentThreadTimes">
            <summary>
            获取当前线程时间
            </summary>
            <returns>线程运行时间</returns>
        </member>
        <member name="M:Arch.Framework.Utility.CodeTimer.GetThreadTimes(System.IntPtr,System.Int64@,System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            Retrieves timing information for the specified thread
            </summary>
            <param name="hThread">A handle to the thread whose timing information is sought</param>
            <param name="lpCreationTime">A pointer to a FILETIME structure that receives the creation time of the thread.</param>
            <param name="lpExitTime">A pointer to a FILETIME structure that receives the exit time of the thread. If the thread has not exited, the content of this structure is undefined.</param>
            <param name="lpKernelTime">A pointer to a FILETIME structure that receives the amount of time that the thread has executed in kernel mode.</param>
            <param name="lpUserTime">A pointer to a FILETIME structure that receives the amount of time that the thread has executed in user mode.</param>
            <returns>If the function succeeds, the return value is nonzero.If the function fails, the return value is zero. To get extended error information, call GetLastError</returns>
        </member>
        <member name="M:Arch.Framework.Utility.CodeTimer.GetCurrentThread">
            <summary>
            Retrieves a pseudo handle for the calling thread
            </summary>
            <returns>The return value is a pseudo handle for the current thread.</returns>
        </member>
        <member name="T:Arch.Framework.Utility.CodeTimer.ActionDelegate">
            <summary>
            方法执行委托
            </summary>
        </member>
        <member name="T:ProtoBuf.Helpers">
            <summary>
            Not all frameworks are created equal (fx1.1 vs fx2.0,
            micro-framework, compact-framework,
            silverlight, etc). This class simply wraps up a few things that would
            otherwise make the real code unnecessarily messy, providing fallback
            implementations if necessary.
            </summary>
        </member>
        <member name="T:ProtoBuf.BclHelpers">
            <summary>
            Provides support for common .NET types that do not have a direct representation
            in protobuf, using the definitions from bcl.proto
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.GetUninitializedObject(System.Type)">
            <summary>
            Creates a new instance of the specified type, bypassing the constructor.
            </summary>
            <param name="type">The type to create</param>
            <returns>The new instance</returns>
            <exception cref="T:System.NotSupportedException">If the platform does not support constructor-skipping</exception>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteTimeSpan(System.TimeSpan,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a TimeSpan to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadTimeSpan(ProtoBuf.ProtoReader)">
            <summary>
            Parses a TimeSpan from a protobuf stream
            </summary>        
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDateTime(ProtoBuf.ProtoReader)">
            <summary>
            Parses a DateTime from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDateTime(System.DateTime,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a DateTime to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDecimal(ProtoBuf.ProtoReader)">
            <summary>
            Parses a decimal from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDecimal(System.Decimal,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a decimal to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteGuid(System.Guid,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a Guid to a protobuf stream
            </summary>        
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadGuid(ProtoBuf.ProtoReader)">
            <summary>
            Parses a Guid from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadNetObject(System.Object,ProtoBuf.ProtoReader,System.Int32,System.Type,ProtoBuf.BclHelpers.NetObjectOptions)">
            <summary>
            Reads an *implementation specific* bundled .NET object, including (as options) type-metadata, identity/re-use, etc.
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteNetObject(System.Object,ProtoBuf.ProtoWriter,System.Int32,ProtoBuf.BclHelpers.NetObjectOptions)">
            <summary>
            Writes an *implementation specific* bundled .NET object, including (as options) type-metadata, identity/re-use, etc.
            </summary>
        </member>
        <member name="T:ProtoBuf.BclHelpers.NetObjectOptions">
            <summary>
            Optional behaviours that introduce .NET-specific functionality
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.None">
            <summary>
            No special behaviour
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.UseConstructor">
            <summary>
            If false, the constructor for the type is bypassed during deserialization, meaning any field initializers
            or other initialization code is skipped.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoPartialIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields. This allows
            ProtoIgnoreAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoPartialIgnoreAttribute.#ctor(System.String)">
            <summary>
            Creates a new ProtoPartialIgnoreAttribute instance.
            </summary>
            <param name="memberName">Specifies the member to be ignored.</param>
        </member>
        <member name="P:ProtoBuf.ProtoPartialIgnoreAttribute.MemberName">
            <summary>
            The name of the member to be ignored.
            </summary>
        </member>
        <member name="T:Arch.Framework.Utility.IDCardHelper">
            <summary>
            身份证工具
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.IDCardHelper.IsChineseIDCard(System.String)">
            <summary>
            检查是否是中国身份证
            </summary>
            <param name="idCardNumber">身份证号码</param>
            <returns>(true = 通过检查, false = 检查失败)</returns>
        </member>
        <member name="M:Arch.Framework.Utility.IDCardHelper.IsChineseIDCard18(System.String)">
            <summary>
            检查是否是18位的中国身份证
            </summary>
            <param name="idCardNumber">身份证号码</param>
            <returns>true = 通过检查, false = 检查失败</returns>
        </member>
        <member name="M:Arch.Framework.Utility.IDCardHelper.IsChineseIDCard15(System.String)">
            <summary>
            检查是否是15位的中国身份证
            </summary>
            <param name="idCardNumber">身份证号码</param>
            <returns>true = 通过检查, false = 检查失败</returns>
        </member>
        <member name="T:Arch.Framework.Utility.ValidateNumber">
            <summary>
            验证码工具
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.ValidateNumber.CreateValidateNumber(System.Int32)">
            <summary>
            生成验证码
            </summary>
            <param name="length">验证码长度</param>
            <returns>随机生成的验证码字符串</returns>       
        </member>
        <member name="M:Arch.Framework.Utility.ValidateNumber.CreateValidateGraphic(System.Web.UI.Page,System.String,System.Int32,System.Int32)">
            <summary>
            创建验证码的图片
            </summary>
            <param name="containsPage">要输出到的page对象</param>
            <param name="validateNum">验证码</param>     
            <param name="width">宽度</param>
            <param name="height">高度</param>
        </member>
        <member name="M:Arch.Framework.Utility.ValidateNumber.GetFontSizePX(System.Int32,System.Int32,System.Int32)">
            <summary>
            获取字体的字号的PX值
            </summary>
            <param name="width">图片宽度</param>
            <param name="height">图片高度</param>
            <param name="validationNumberLength">验证码长度</param>
            <returns>字号的PX值</returns>        
        </member>
        <member name="T:Arch.Framework.Utility.Serialize.SerializeMethod">
            <summary>
            序列化方式
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.Serialize.SerializeMethod.Bin">
            <summary>
            二进制序列化
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.Serialize.SerializeMethod.Base64">
            <summary>
            Base64序列化
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.Serialize.SerializeMethod.Google">
            <summary>
            Google序列化
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.Serialize.SerializeMethod.NameValue">
            <summary>
            NameValue序列化
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.Serialize.SerializeMethod.Soap">
            <summary>
            SOAP序列化
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.Serialize.SerializeMethod.Xml">
            <summary>
            XML序列化
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer">
            <summary>
            Provides protocol-buffer serialization capability for concrete, attributed types. This
            is a *default* model, but custom serializer models are also supported.
            </summary>
            <remarks>
            Protocol-buffer serialization is a compact binary format, designed to take
            advantage of sparse data and knowledge of specific data types; it is also
            extensible, allowing a type to be deserialized / merged even if some data is
            not recognised.
            </remarks>
        </member>
        <member name="F:ProtoBuf.Serializer.ListItemTag">
            <summary>
            The field number that is used as a default when serializing/deserializing a list of objects.
            The data is treated as repeated message with field number 1.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.GetProto``1">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <typeparam name="T">The type to generate a .proto definition for</typeparam>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeepClone``1(``0)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.IO.Stream,``0)">
            <summary>
            Applies a protocol-buffer stream to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Deserialize``1(System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.IO.Stream,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.ChangeType``2(``0)">
            <summary>
            Serializes a given instance and deserializes it as a different type;
            this can be used to translate between wire-compatible objects (where
            two .NET types represent the same data), or to promote/demote a type
            through an inheritance hierarchy.
            </summary>
            <remarks>No assumption of compatibility is made between the types.</remarks>
            <typeparam name="TFrom">The type of the object being copied.</typeparam>
            <typeparam name="TTo">The type of the new object to be created.</typeparam>
            <param name="instance">The existing instance to use as a template.</param>
            <returns>A new instane of type TNewType, with the data from TOldType.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.PrepareSerializer``1">
            <summary>
            Precompiles the serializer for a given type.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="fieldNumber">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="fieldNumber">The expected tag of the item (only used with base-128 prefix style).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.MergeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
            <summary>
            Applies a protocol-buffer stream to an existing instance, using length-prefixed
            data - useful with network IO.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="source">The stream containing the data to investigate for a length.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.Byte[],System.Int32,System.Int32,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="buffer">The buffer containing the data to investigate for a length.</param>
            <param name="index">The offset of the first byte to read from the buffer.</param>
            <param name="count">The number of bytes to read from the buffer.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="T:ProtoBuf.Serializer.NonGeneric">
            <summary>
            Provides non-generic access to the default serializer.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.DeepClone(System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Deserialize(System.Type,System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <param name="type">The type to be created.</param>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.SerializeWithLengthPrefix(System.IO.Stream,System.Object,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.TryDeserializeWithLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,ProtoBuf.Serializer.TypeResolver,System.Object@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.CanSerialize(System.Type)">
            <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.GlobalOptions">
            <summary>
            Global switches that change the behavior of protobuf-net
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializer.GlobalOptions.InferTagFromName">
            <summary>
            <see cref="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault"/>
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.TypeResolver">
            <summary>
            Maps a field-number to a type
            </summary>
        </member>
        <member name="T:Arch.Framework.Utility.ChineseConverter">
            <summary>
            汉字转换成拼音,包括功能全拼和缩写
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.ChineseConverter.pyValue">
            <summary>
            汉字的机内码数组
            </summary>
        </member>
        <member name="F:Arch.Framework.Utility.ChineseConverter.pyName">
            <summary>
            机内码对应的拼音数组
            </summary>
        </member>
        <member name="M:Arch.Framework.Utility.ChineseConverter.Convert(System.String,System.String)">
            <summary>
            把汉字转换成拼音(全拼) 
            </summary>
            <param name="hzString">汉字字符串</param>
            <param name="splitChar">分隔符</param>
            <returns>返回转换后的拼音</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ChineseConverter.GetSpellStringLower(System.String)">
            <summary>
            汉字转拼音缩写
            </summary>
            <param name="str">要转换的汉字字符串</param>
            <returns>拼音缩写</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ChineseConverter.GetSpellStringSupper(System.String)">
            <summary>
            汉字转拼音缩写 (大写)
            </summary>
            <param name="str">要转换的汉字字符串</param>
            <returns>拼音缩写</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ChineseConverter.GetSpellCharSupper(System.String)">
            <summary>
            取单个字符的拼音声母
            </summary>
            <param name="c">要转换的单个汉字</param>
            <returns>拼音声母</returns>
        </member>
        <member name="M:Arch.Framework.Utility.ChineseConverter.GetSpellCharLower(System.String)">
            <summary>
            取单个字符的拼音声母
            </summary>
            <param name="c">要转换的单个汉字</param>
            <returns>拼音声母</returns>
        </member>
    </members>
</doc>
